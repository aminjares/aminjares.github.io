### Case Study: Heroku

In Heroku.com, Heroku's platform is designed to maximize the developer's productivity and provide the developer with a good experience of learning the capabilities of Heroku. Heroku extends this platform with a range of tools that support modern development practices, such as continuous delivery. Continuous delivery features short release cycles, automation, and a direct connection to the source code repository. Continuous delivery is designed to keep teams updated constant to production  safe with less time. Heroku flow is a cycle that sends out workflow that combines actons with GitHub, visually presented pipelines, disposable “review apps” and Heroku CI. Heroku Flow is designed to streamline the app release experience by making continuous delivery easy, visual, and efficient. 

A pipeline is a group of Heroku apps that each repsents either deployment, review, staging, or production. pipeline comes in handy when managing multiple environments for a app by following the five steps. First, the developer creates a pull request to make a change to the codebase. Second, Heroku automatically creates a review app for the pull request that allows the developers to test the change. Third, after the change is complete it will merge into the codebase’s master branch. Fourth, the master branch is automatically sented to the pipeline’s staging app for additional testing. Last, a developer promotes the staging app to production to make it available to the app’s end users. Pipelines let the developer know how the deployed code flows from one environment to the next.

Heroku CI is a low-setup, visual test runner that integrates with Heroku Pipelines to automatically run the developer's tests on every push to GitHub, using disposable apps. Heroku CI automatically runs app’s test suite with every push to app’s GitHub repository, making it easy to review test results before merging or deploying changes to the codebase. Tests execute in a disposable environment that closely resembles the staging and production environments, which helps to ensure that results are accurate and obtained safely. The scripts section of the "app.json" manifest lets you override the commands that Heroku CI runs to set up and then run the test suite. The scripts field can have two keys that can be any shell command, including the path to an executable that exists within the application repo called test-setup and test. A "test-setup" script performs one-time setup tasks before running the test suite. The "test" script is the command the developer use to execute their tests. The environment variables are available in all Heroku CI test runs and cannot be changed such as, CI, Heroku_test_run_branch, Heroku_test_run_commit_version, and Heroku_test_run_ID. The "CI" is a string indicating that this is a continuous integration environment and value is always true. The "HEROKU_TEST_RUN_BRANCH" is a string representing the branch of the commit being tested. The "HEROKU_TEST_RUN_COMMIT_VERSION" is a string representing the commit version being tested that is usually the commit’s SHA. The "HEROKU_TEST_RUN_ID" is a string UUID representing the unique ID of the test run. Heroku CI offers language support via the Testpack API, which allows a buildpack to prepare the app for testing and detect what tests to run. Heroku’s officially supported languages have full Heroku CI support. Some third-party buildpacks also provide support. The Heroku Go buildpack compiles and installs dependencies with detected tool (e.g. govendor, godep) and runs tests with go test ./…. The Heroku Node buildpack compiles the tests with NPM_CONFIG_PRODUCTION=false and NODE_ENV=test in which installs the test and dev dependencies. Also, runs your tests with npm test or yarn test as appropriate.
