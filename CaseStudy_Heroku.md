### Case Study: Heroku

In Heroku.com, Heroku's platform is designed to maximize the developer's productivity and provide the developer with a good experience of learning the capabilities of Heroku. Heroku extends this platform with a range of tools that support modern development practices, such as continuous delivery. Continuous delivery features short release cycles, automation, and a direct connection to the source code repository. Continuous delivery is designed to keep teams updated constant to production  safe with less time. Heroku flow is a cycle that sends out workflow that combines actons with GitHub, visually presented pipelines, disposable “review apps” and Heroku CI. Heroku Flow is designed to streamline the app release experience by making continuous delivery easy, visual, and efficient. 

A pipeline is a group of Heroku apps that each repsents either deployment, review, staging, or production. pipeline comes in handy when managing multiple environments for a app by following the five steps. First, the developer creates a pull request to make a change to the codebase. Second, Heroku automatically creates a review app for the pull request that allows the developers to test the change. Third, after the change is complete it will merge into the codebase’s master branch. Fourth, the master branch is automatically sented to the pipeline’s staging app for additional testing. Last, a developer promotes the staging app to production to make it available to the app’s end users. Pipelines let the developer know how the deployed code flows from one environment to the next.

Heroku CI is a low-setup, visual test runner that integrates with Heroku Pipelines to automatically run the developer's tests on every push to GitHub, using disposable apps. Heroku CI automatically runs app’s test suite with every push to app’s GitHub repository, making it easy to review test results before merging or deploying changes to the codebase. Tests execute in a disposable environment that closely resembles the staging and production environments, which helps to ensure that results are accurate and obtained safely. The scripts section of the "app.json" manifest lets you override the commands that Heroku CI runs to set up and then run the test suite. The scripts field can have two keys that can be any shell command, including the path to an executable that exists within the application repo called test-setup and test. A "test-setup" script performs one-time setup tasks before running the test suite. The "test" script is the command the developer use to execute their tests. The environment variables are available in all Heroku CI test runs and cannot be changed such as, CI, Heroku_test_run_branch, Heroku_test_run_commit_version, and Heroku_test_run_ID. The "CI" is a string indicating that this is a continuous integration environment and value is always true. The "HEROKU_TEST_RUN_BRANCH" is a string representing the branch of the commit being tested. The "HEROKU_TEST_RUN_COMMIT_VERSION" is a string representing the commit version being tested that is usually the commit’s SHA. The "HEROKU_TEST_RUN_ID" is a string UUID representing the unique ID of the test run. Heroku CI offers language support via the Testpack API, which allows a buildpack to prepare the app for testing and detect what tests to run. Heroku’s officially supported languages have full Heroku CI support. Some third-party buildpacks also provide support. The Heroku Go buildpack compiles and installs dependencies with detected tool (e.g. govendor, godep) and runs tests with go test ./…. The Heroku Node buildpack compiles the tests with NPM_CONFIG_PRODUCTION=false and NODE_ENV=test in which installs the test and dev dependencies. Also, runs the tests with npm test or yarn test as appropriate. The Heroku Java buildpack compiles test source code into the target directory by executing Maven’s test-compile lifecycle and executes tests by running mvn -B test or mvnw -B test depending on the Maven wrapper. The Heroku PHP buildpack dependencies from require-dev in composer.json will be installed for test runs. The Heroku Python buildpack is all dependencies specified within requirements.txt and optionally requirements-test.txt will be installed. The Python buildpack does not automatically detect the tests. the developer needs to tell Heroku CI what tests to run with scripts.test in the app.json. The Heroku Ruby buildpack supports both :ruby or :sql database schema when preparing database tests and will run rake db:migrate. It installs development and test dependencies defined in the Gemfile. Also, runs the tests with the appropriate Rake command (e.g. bundle exec rspec, bin/rails test, or rake test). The Heroku Gradle buildpack runs tests with gradlew test. The Heroku Scala buildpack runs tests with sbt test. The Heroku Clojure buildpack prepares test environment by running lein deps in which will be overrided by the LEIN_BUILD_TASK config var. Also, runs tests with lein test. The third-party Elixir buildpack compiles and installs dependencies with MIX_ENV=test. In addition, runs tests with mix test. Elixir is not an officially supported language, the developer must still specify the buildpack in the app.json file. Also make sure that the test alias in the mix.exs file does not create a database, because adding the Heroku Postgres add-on does that for the developer. The Heroku CLI includes a ci:debug command that the dveloper can use to start a debug test run. This enables the developer to inspect the Heroku CI environment and the execution of tests inside a test dyno. This is handy for solving issues where tests pass locally but not on CI, or for debugging problems with test setup.






